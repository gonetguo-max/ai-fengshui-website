# AI风水分析网站 - 技术实现方案

## 1. 3档产品技术架构

### 1.1 产品分级逻辑设计

**核心设计原则：**
- 所有用户使用同一套AI分析引擎
- 通过输出控制实现不同档次的差异
- 保持代码简洁，避免重复开发

**分级控制策略：**

```javascript
// 产品分级枚举
const PRODUCT_TIERS = {
    FREE: 'free',
    STANDARD: 'standard', 
    PREMIUM: 'premium'
};

// 分级配置
const TIER_CONFIG = {
    free: {
        maxProblems: 3,           // 最多显示3个问题
        showScores: false,        // 不显示评分
        solutionsPerProblem: 1,   // 每个问题1个解决方案
        showUpgrade: true,        // 显示升级提示
        reportFormat: 'simple'    // 简单报告格式
    },
    standard: {
        maxProblems: 999,         // 显示所有问题
        showScores: true,         // 显示分区评分
        solutionsPerProblem: 3,   // 每个问题3个解决方案
        showUpgrade: true,        // 显示升级到Premium
        reportFormat: 'detailed', // 详细报告格式
        pdfDownload: true         // 支持PDF下载
    },
    premium: {
        maxProblems: 999,         // 显示所有问题
        showScores: true,         // 显示分区评分
        solutionsPerProblem: 5,   // 每个问题5个解决方案
        showUpgrade: false,       // 不显示升级
        reportFormat: 'premium',  // 高级报告格式
        pdfDownload: true,        // 支持PDF下载
        personalizedAnalysis: true, // 生辰八字分析
        actionPlan: true,         // 阶段性行动计划
        consultationAccess: true  // 咨询服务
    }
};
```

### 1.2 权限控制系统

**用户识别机制：**
- 验证期：基于指纹识别，所有用户默认FREE级别
- 商业化后：基于用户账户和订单记录

**权限检查流程：**

```javascript
// 权限管理器
class TierManager {
    constructor() {
        this.validationMode = process.env.VALIDATION_MODE === 'true';
    }
    
    // 获取用户等级
    getUserTier(fingerprint, orderId = null) {
        if (this.validationMode) {
            // 验证期模式：所有用户FREE，但可以模拟升级
            const simulatedTier = this.getSimulatedTier(fingerprint);
            return simulatedTier || 'free';
        }
        
        // 正式商业化模式：基于订单查询
        return this.getTierByOrder(orderId) || 'free';
    }
    
    // 验证期模拟升级（用于测试付费意愿）
    simulateUpgrade(fingerprint, targetTier, email) {
        this.recordUpgradeIntent(fingerprint, {
            targetTier,
            email,
            timestamp: new Date(),
            simulated: true
        });
        
        // 临时给用户高级权限体验
        this.setSimulatedTier(fingerprint, targetTier, 24 * 60 * 60 * 1000); // 24小时
        
        return {
            success: true,
            message: `验证期免费体验${targetTier}功能24小时`,
            tier: targetTier
        };
    }
}
```

### 1.3 分析深度控制机制

**AI分析流程控制：**

```javascript
// 原有的风水分析器升级
class FengshuiAnalyzer {
    async analyze(formData, language, tier = 'free') {
        // 1. AI分析（所有级别都进行完整分析）
        const fullAnalysis = await this.performFullAnalysis(formData, language);
        
        // 2. 根据级别过滤输出
        const filteredResult = this.filterByTier(fullAnalysis, tier);
        
        // 3. 添加级别特定内容
        const enhancedResult = await this.enhanceByTier(filteredResult, formData, tier);
        
        return enhancedResult;
    }
    
    // 根据级别过滤分析结果
    filterByTier(analysis, tier) {
        const config = TIER_CONFIG[tier];
        
        return {
            // 基础信息（所有级别）
            summary: analysis.summary,
            overallGrade: analysis.overallGrade,
            
            // 问题列表（按级别限制）
            problems: analysis.problems.slice(0, config.maxProblems).map(problem => ({
                ...problem,
                solutions: problem.solutions.slice(0, config.solutionsPerProblem)
            })),
            
            // 评分信息（按级别显示）
            scores: config.showScores ? analysis.scores : null,
            
            // 升级提示
            upgradePrompt: config.showUpgrade ? this.generateUpgradePrompt(tier) : null
        };
    }
    
    // 根据级别增强分析结果
    async enhanceByTier(result, formData, tier) {
        const config = TIER_CONFIG[tier];
        
        if (tier === 'premium' && config.personalizedAnalysis) {
            // Premium级别：添加生辰八字分析
            if (formData.birthDate && formData.birthTime) {
                result.personalizedAdvice = await this.generatePersonalizedAdvice(
                    formData.birthDate, 
                    formData.birthTime, 
                    result
                );
            }
            
            // 添加阶段性行动计划
            if (config.actionPlan) {
                result.actionPlan = this.generateActionPlan(result.problems);
            }
        }
        
        return result;
    }
}
```

## 2. 代码实现详解

### 2.1 风水分析器分级改造

**现有代码路径：** `src/api/fengshui-analyzer.js`

**主要修改点：**

1. **在analyze方法中添加tier参数：**

```javascript
// 原有方法签名
async analyze(formData, language) { ... }

// 新方法签名  
async analyze(formData, language, tier = 'free') { ... }
```

2. **升级提示生成器：**

```javascript
generateUpgradePrompt(currentTier) {
    const prompts = {
        free: {
            zh: {
                title: "升级获得完整分析",
                features: [
                    "识别所有风水问题（当前仅显示前3个）",
                    "详细的房间评分系统", 
                    "专业的改善方案",
                    "PDF报告下载"
                ],
                cta: "升级到标准版 ¥139",
                note: "验证期间点击可免费体验完整功能"
            },
            en: {
                title: "Upgrade for Complete Analysis", 
                features: [
                    "Identify all feng shui issues (currently showing only 3)",
                    "Detailed room scoring system",
                    "Professional improvement solutions",
                    "PDF report download"
                ],
                cta: "Upgrade to Standard $19.99",
                note: "Click to experience full features for free during validation"
            }
        },
        standard: {
            zh: {
                title: "个性定制版更精准",
                features: [
                    "生辰八字与户型匹配分析",
                    "个性化摆设建议",
                    "分阶段优化计划",
                    "专属咨询服务"
                ],
                cta: "升级到定制版 ¥349"
            },
            en: {
                title: "Premium Version More Accurate",
                features: [
                    "Birth date and layout matching analysis",
                    "Personalized placement suggestions", 
                    "Phased optimization plan",
                    "Exclusive consultation service"
                ],
                cta: "Upgrade to Premium $49.99"
            }
        }
    };
    
    return prompts[currentTier];
}
```

### 2.2 用户等级识别和管理

**现有代码路径：** `src/utils/user-manager.js`

**添加等级管理功能：**

```javascript
class UserManager {
    constructor() {
        // 现有代码保持不变
        this.users = new Map();
        
        // 新增：用户等级管理
        this.userTiers = new Map();
        this.upgradeIntents = new Map();
    }
    
    // 新增：获取用户等级
    getUserTier(fingerprint) {
        const validationMode = process.env.VALIDATION_MODE === 'true';
        
        if (validationMode) {
            // 验证期：检查是否有模拟升级
            const simulated = this.userTiers.get(fingerprint);
            if (simulated && simulated.expiry > Date.now()) {
                return simulated.tier;
            }
            return 'free';
        }
        
        // 正式模式：基于订单记录（待实现）
        return this.getTierFromDatabase(fingerprint);
    }
    
    // 新增：记录升级意愿
    recordUpgradeIntent(fingerprint, data) {
        const intents = this.upgradeIntents.get(fingerprint) || [];
        intents.push({
            ...data,
            timestamp: new Date(),
            id: this.generateId()
        });
        this.upgradeIntents.set(fingerprint, intents);
        
        // 记录到统计数据
        this.recordEvent(fingerprint, {
            type: 'upgrade_intent',
            tier: data.targetTier,
            email: data.email
        });
    }
    
    // 新增：模拟升级（验证期用）
    simulateUpgrade(fingerprint, tier, duration = 24 * 60 * 60 * 1000) {
        this.userTiers.set(fingerprint, {
            tier: tier,
            expiry: Date.now() + duration,
            simulated: true
        });
    }
    
    // 新增：获取升级意愿统计
    getUpgradeIntentStats() {
        let totalIntents = 0;
        let tierBreakdown = { standard: 0, premium: 0 };
        let emailsCollected = 0;
        
        for (let [fingerprint, intents] of this.upgradeIntents) {
            totalIntents += intents.length;
            
            intents.forEach(intent => {
                tierBreakdown[intent.targetTier] = (tierBreakdown[intent.targetTier] || 0) + 1;
                if (intent.email) emailsCollected++;
            });
        }
        
        return {
            totalIntents,
            tierBreakdown,
            emailsCollected,
            conversionRate: totalIntents > 0 ? (emailsCollected / totalIntents * 100).toFixed(2) : 0
        };
    }
}
```

### 2.3 报告生成分级逻辑

**报告格式控制：**

```javascript
// 报告生成器升级
class ReportGenerator {
    generateReport(analysis, tier, language = 'zh') {
        const config = TIER_CONFIG[tier];
        
        // 基础报告结构（所有级别）
        const baseReport = {
            id: this.generateReportId(),
            timestamp: new Date().toISOString(),
            tier: tier,
            language: language,
            summary: analysis.summary,
            overallGrade: analysis.overallGrade
        };
        
        // 根据级别生成不同内容
        switch(tier) {
            case 'free':
                return this.generateFreeReport(baseReport, analysis);
            case 'standard':
                return this.generateStandardReport(baseReport, analysis);
            case 'premium':
                return this.generatePremiumReport(baseReport, analysis);
        }
    }
    
    generateFreeReport(baseReport, analysis) {
        return {
            ...baseReport,
            problems: analysis.problems.slice(0, 3).map(p => ({
                title: p.title,
                severity: p.severity,
                description: p.description,
                quickFix: p.solutions[0] // 只显示第一个解决方案
            })),
            limitations: {
                shown: 3,
                total: analysis.problems.length,
                message: `发现${analysis.problems.length}个风水问题，当前仅显示最重要的3个`
            },
            upgradePrompt: analysis.upgradePrompt
        };
    }
    
    generateStandardReport(baseReport, analysis) {
        return {
            ...baseReport,
            problems: analysis.problems.map(p => ({
                title: p.title,
                severity: p.severity,
                description: p.description,
                solutions: p.solutions.slice(0, 3), // 显示3个解决方案
                impact: p.impact,
                urgency: p.urgency
            })),
            roomScores: analysis.scores,
            recommendations: this.generateRecommendations(analysis),
            downloadUrl: `/api/reports/${baseReport.id}/pdf`,
            upgradePrompt: analysis.upgradePrompt // 提示升级到Premium
        };
    }
    
    generatePremiumReport(baseReport, analysis) {
        return {
            ...baseReport,
            problems: analysis.problems.map(p => ({
                title: p.title,
                severity: p.severity,
                description: p.description,
                solutions: p.solutions, // 显示所有解决方案
                impact: p.impact,
                urgency: p.urgency,
                personalizedNote: p.personalizedNote
            })),
            roomScores: analysis.scores,
            personalizedAdvice: analysis.personalizedAdvice,
            actionPlan: analysis.actionPlan,
            recommendations: this.generateAdvancedRecommendations(analysis),
            downloadUrl: `/api/reports/${baseReport.id}/pdf`,
            consultationInfo: {
                available: true,
                contact: process.env.CONSULTATION_EMAIL,
                note: "Premium用户享有专属咨询服务"
            }
        };
    }
}
```

### 2.4 前端交互界面实现

**升级提示UI组件：**

```html
<!-- 升级提示组件 -->
<div id="upgrade-prompt" class="upgrade-prompt" style="display: none;">
    <div class="upgrade-content">
        <h3 class="upgrade-title"></h3>
        <ul class="upgrade-features"></ul>
        <div class="upgrade-actions">
            <button class="upgrade-btn primary" onclick="handleUpgrade()">
                <span class="btn-text"></span>
            </button>
            <button class="upgrade-btn secondary" onclick="closeUpgradePrompt()">
                稍后再说
            </button>
        </div>
        <p class="upgrade-note"></p>
    </div>
</div>
```

```javascript
// 升级提示JavaScript
function showUpgradePrompt(promptData, currentTier) {
    const prompt = document.getElementById('upgrade-prompt');
    const title = prompt.querySelector('.upgrade-title');
    const features = prompt.querySelector('.upgrade-features');
    const btnText = prompt.querySelector('.btn-text');
    const note = prompt.querySelector('.upgrade-note');
    
    // 填充内容
    title.textContent = promptData.title;
    btnText.textContent = promptData.cta;
    note.textContent = promptData.note || '';
    
    // 清空并填充功能列表
    features.innerHTML = '';
    promptData.features.forEach(feature => {
        const li = document.createElement('li');
        li.textContent = feature;
        features.appendChild(li);
    });
    
    // 显示提示框
    prompt.style.display = 'block';
    prompt.dataset.targetTier = currentTier === 'free' ? 'standard' : 'premium';
}

async function handleUpgrade() {
    const prompt = document.getElementById('upgrade-prompt');
    const targetTier = prompt.dataset.targetTier;
    
    // 验证期间：收集邮箱并模拟升级
    if (isValidationMode()) {
        const email = await collectEmail(targetTier);
        if (email) {
            await simulateUpgrade(targetTier, email);
        }
    } else {
        // 正式模式：跳转到支付页面
        window.location.href = `/payment?tier=${targetTier}`;
    }
}

async function collectEmail(targetTier) {
    return new Promise((resolve) => {
        const email = prompt(`感谢您的关注！请留下邮箱，${targetTier === 'standard' ? '标准版' : '定制版'}开放时第一时间通知您：`);
        
        if (email && validateEmail(email)) {
            // 记录升级意愿
            fetch('/api/upgrade-intent', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    tier: targetTier,
                    email: email
                })
            });
            resolve(email);
        } else {
            resolve(null);
        }
    });
}
```

## 3. 数据库设计方案

### 3.1 用户数据表设计

**考虑到当前系统使用内存存储，设计兼容的数据结构：**

```javascript
// 用户数据结构（当前内存存储）
const UserSchema = {
    fingerprint: String,        // 用户指纹ID（主键）
    createdAt: Date,           // 首次访问时间
    lastUsed: Date,            // 最后使用时间
    usageCount: Number,        // 使用次数
    region: String,            // 地理区域
    language: String,          // 语言偏好
    metadata: Array,           // 使用元数据
    tier: String,              // 用户等级 (free/standard/premium)
    subscription: {            // 订阅信息
        active: Boolean,
        expiry: Date,
        orderId: String
    }
};

// 升级意愿记录结构
const UpgradeIntentSchema = {
    id: String,                // 记录ID
    fingerprint: String,       // 用户指纹
    targetTier: String,        // 目标等级
    email: String,             // 用户邮箱
    timestamp: Date,           // 记录时间
    simulated: Boolean,        // 是否为模拟升级
    converted: Boolean,        // 是否最终转化
    conversionDate: Date       // 转化日期
};
```

### 3.2 分析记录表设计

```javascript
// 分析记录数据结构
const AnalysisSchema = {
    id: String,                // 分析记录ID
    fingerprint: String,       // 用户指纹
    tier: String,              // 使用的产品等级
    timestamp: Date,           // 分析时间
    inputData: {               // 输入数据
        houseType: String,
        direction: String,
        hasPhoto: Boolean,
        photoName: String,
        additionalInfo: Object
    },
    results: {                 // 分析结果
        overallGrade: Number,
        problems: Array,
        scores: Object,
        aiProvider: String,    // 使用的AI提供商
        processingTime: Number // 处理时间（毫秒）
    },
    userFeedback: {           // 用户反馈
        rating: Number,
        comment: String,
        feedbackDate: Date
    }
};
```

### 3.3 付费记录表设计

```javascript
// 订单记录数据结构（为商业化准备）
const OrderSchema = {
    orderId: String,           // 订单ID
    fingerprint: String,       // 用户指纹
    email: String,             // 用户邮箱
    tier: String,              // 购买等级
    amount: Number,            // 支付金额
    currency: String,          // 货币类型
    status: String,            // 订单状态 (pending/paid/failed/refunded)
    paymentProvider: String,   // 支付提供商
    paymentId: String,         // 支付流水号
    createdAt: Date,           // 订单创建时间
    paidAt: Date,              // 支付完成时间
    expiryAt: Date,            // 服务到期时间
    refundedAt: Date           // 退款时间
};
```

### 3.4 数据关系和索引优化

```javascript
// 数据管理器（统一管理所有数据结构）
class DataManager {
    constructor() {
        // 主要数据存储
        this.users = new Map();           // fingerprint -> UserSchema
        this.analyses = new Map();        // analysisId -> AnalysisSchema  
        this.upgradeIntents = new Map();  // fingerprint -> [UpgradeIntentSchema]
        this.orders = new Map();          // orderId -> OrderSchema
        
        // 索引（提升查询性能）
        this.usersByRegion = new Map();   // region -> [fingerprint]
        this.analysesByDate = new Map();  // dateString -> [analysisId]
        this.ordersByUser = new Map();    // fingerprint -> [orderId]
    }
    
    // 用户相关操作
    createUser(fingerprint, metadata) {
        const user = {
            fingerprint,
            createdAt: new Date(),
            lastUsed: new Date(),
            usageCount: 1,
            region: metadata.region || 'unknown',
            language: metadata.language || 'zh',
            metadata: [metadata],
            tier: 'free',
            subscription: {
                active: false,
                expiry: null,
                orderId: null
            }
        };
        
        this.users.set(fingerprint, user);
        this.updateUserIndex(user);
        return user;
    }
    
    // 分析记录操作
    saveAnalysis(fingerprint, tier, inputData, results) {
        const analysisId = this.generateId();
        const analysis = {
            id: analysisId,
            fingerprint,
            tier,
            timestamp: new Date(),
            inputData,
            results,
            userFeedback: null
        };
        
        this.analyses.set(analysisId, analysis);
        this.updateAnalysisIndex(analysis);
        return analysisId;
    }
    
    // 查询方法
    getAnalysesByUser(fingerprint, limit = 10) {
        const userAnalyses = [];
        for (let [id, analysis] of this.analyses) {
            if (analysis.fingerprint === fingerprint) {
                userAnalyses.push(analysis);
            }
        }
        return userAnalyses
            .sort((a, b) => b.timestamp - a.timestamp)
            .slice(0, limit);
    }
    
    getAnalyticsSummary() {
        const today = new Date().toDateString();
        const todayAnalyses = this.analysesByDate.get(today) || [];
        
        return {
            totalUsers: this.users.size,
            totalAnalyses: this.analyses.size,
            todayAnalyses: todayAnalyses.length,
            upgradeIntents: Array.from(this.upgradeIntents.values()).reduce((sum, intents) => sum + intents.length, 0),
            tierDistribution: this.getTierDistribution()
        };
    }
}
```

## 4. API接口设计

### 4.1 分析请求接口升级

**现有接口：** `POST /api/analyze`

**升级改造：**

```javascript
// 升级后的分析接口
app.post('/api/analyze', upload.single('photo'), async (req, res) => {
    try {
        const fingerprint = userManager.generateFingerprint(req);
        
        // 1. 获取用户等级
        const userTier = userManager.getUserTier(fingerprint);
        const requestedTier = req.body.tier || userTier;
        
        // 2. 验证等级权限
        if (!userManager.hasAccess(fingerprint, requestedTier)) {
            return res.status(403).json({
                success: false,
                error: '等级权限不足',
                currentTier: userTier,
                requiredTier: requestedTier
            });
        }
        
        // 3. 准备分析数据
        const formData = {
            houseType: req.body.houseType || req.body.roomType,
            direction: req.body.direction,
            // ... 其他现有字段保持不变
            photo: req.file ? req.file.filename : null
        };
        
        // 4. 执行分析（添加tier参数）
        const language = req.body.language || 'zh';
        let analysisResult;
        
        if (validateConfig()) {
            analysisResult = await analyzer.analyze(formData, language, requestedTier);
        } else {
            analysisResult = analyzer.generateSampleAnalysis(formData, language, requestedTier);
        }
        
        // 5. 记录分析数据
        const analysisId = dataManager.saveAnalysis(fingerprint, requestedTier, formData, analysisResult);
        userManager.recordUsage(fingerprint, {
            tier: requestedTier,
            hasImage: !!req.file,
            analysisId: analysisId
        });
        
        // 6. 生成报告
        const report = reportGenerator.generateReport(analysisResult, requestedTier, language);
        
        res.json({
            success: true,
            data: {
                ...report,
                analysisId: analysisId,
                userTier: userTier
            }
        });
        
    } catch (error) {
        console.error('❌ 分析请求失败:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});
```

### 4.2 用户状态查询接口

**新增接口：** `GET /api/user-status`

```javascript
app.get('/api/user-status', (req, res) => {
    try {
        const fingerprint = userManager.generateFingerprint(req);
        const user = userManager.getUser(fingerprint);
        
        if (!user) {
            return res.json({
                success: true,
                data: {
                    isNew: true,
                    tier: 'free',
                    usageCount: 0
                }
            });
        }
        
        const recentAnalyses = dataManager.getAnalysesByUser(fingerprint, 5);
        const upgradeIntents = userManager.getUpgradeIntents(fingerprint);
        
        res.json({
            success: true,
            data: {
                fingerprint: fingerprint,
                tier: user.tier,
                usageCount: user.usageCount,
                lastUsed: user.lastUsed,
                region: user.region,
                language: user.language,
                subscription: user.subscription,
                recentAnalyses: recentAnalyses.map(a => ({
                    id: a.id,
                    tier: a.tier,
                    timestamp: a.timestamp,
                    overallGrade: a.results.overallGrade
                })),
                upgradeIntents: upgradeIntents.length,
                canUpgrade: this.canUserUpgrade(user.tier)
            }
        });
        
    } catch (error) {
        console.error('获取用户状态失败:', error);
        res.status(500).json({
            success: false,
            error: '获取用户状态失败'
        });
    }
});

// 辅助方法
function canUserUpgrade(currentTier) {
    return {
        toStandard: currentTier === 'free',
        toPremium: ['free', 'standard'].includes(currentTier)
    };
}
```

### 4.3 升级意愿收集接口

**新增接口：** `POST /api/upgrade-intent`

```javascript
app.post('/api/upgrade-intent', async (req, res) => {
    try {
        const { tier, email, simulate = false } = req.body;
        const fingerprint = userManager.generateFingerprint(req);
        
        // 验证输入
        if (!['standard', 'premium'].includes(tier)) {
            return res.status(400).json({
                success: false,
                error: '无效的等级选择'
            });
        }
        
        if (!email || !validateEmail(email)) {
            return res.status(400).json({
                success: false,
                error: '请提供有效的邮箱地址'
            });
        }
        
        // 记录升级意愿
        userManager.recordUpgradeIntent(fingerprint, {
            targetTier: tier,
            email: email,
            simulated: simulate
        });
        
        let responseData = {
            success: true,
            message: '感谢您的关注！',
            tier: tier
        };
        
        // 验证期：模拟升级体验
        if (simulate && process.env.VALIDATION_MODE === 'true') {
            userManager.simulateUpgrade(fingerprint, tier);
            
            responseData.upgraded = true;
            responseData.message = `已为您开通${tier === 'standard' ? '标准版' : '定制版'}24小时体验！`;
            responseData.expiryHours = 24;
            
            // 发送体验链接
            if (email) {
                await sendExperienceEmail(email, tier, fingerprint);
            }
        } else {
            // 正式模式：发送开放通知邮件
            responseData.message = '开放时将第一时间通知您！';
            responseData.eta = '预计2-4周内开放';
        }
        
        res.json(responseData);
        
    } catch (error) {
        console.error('记录升级意愿失败:', error);
        res.status(500).json({
            success: false,
            error: '记录升级意愿失败'
        });
    }
});
```

### 4.4 数据统计接口

**新增接口：** `GET /api/analytics-dashboard`

```javascript
app.get('/api/analytics-dashboard', (req, res) => {
    try {
        // 仅在开发模式或管理员权限下可访问
        if (process.env.NODE_ENV === 'production' && !req.headers['admin-key']) {
            return res.status(403).json({
                success: false,
                error: '访问权限不足'
            });
        }
        
        const analytics = dataManager.getAnalyticsSummary();
        const upgradeStats = userManager.getUpgradeIntentStats();
        const aiStats = analyzer.aiManager.getPerformanceStats();
        
        res.json({
            success: true,
            data: {
                overview: analytics,
                conversion: {
                    ...upgradeStats,
                    conversionFunnel: this.getConversionFunnel()
                },
                technical: {
                    ai: aiStats,
                    system: {
                        uptime: process.uptime(),
                        memory: process.memoryUsage(),
                        timestamp: new Date().toISOString()
                    }
                },
                trends: this.getTrendData()
            }
        });
        
    } catch (error) {
        console.error('获取分析数据失败:', error);
        res.status(500).json({
            success: false,
            error: '获取分析数据失败'
        });
    }
});
```

## 5. 验证期特殊功能

### 5.1 "伪付费"功能实现

**核心设计思路：**
让用户体验完整的付费流程，但实际不收费，同时收集付费意愿数据。

```javascript
// 验证期支付模拟器
class ValidationPaymentSimulator {
    constructor() {
        this.simulatedTransactions = new Map();
        this.userExperiences = new Map();
    }
    
    // 模拟支付流程
    async simulatePayment(fingerprint, tier, email) {
        const transactionId = this.generateTransactionId();
        const amount = this.getTierPrice(tier);
        
        // 1. 创建模拟订单
        const simulatedOrder = {
            id: transactionId,
            fingerprint: fingerprint,
            email: email,
            tier: tier,
            amount: amount,
            currency: 'USD',
            status: 'simulated_success',
            createdAt: new Date(),
            validUntil: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24小时
        };
        
        this.simulatedTransactions.set(transactionId, simulatedOrder);
        
        // 2. 给用户临时高级权限
        this.grantTemporaryAccess(fingerprint, tier, 24);
        
        // 3. 记录用户付费意愿
        this.recordPaymentIntent(fingerprint, {
            tier: tier,
            amount: amount,
            email: email,
            timestamp: new Date(),
            transactionId: transactionId
        });
        
        return {
            success: true,
            transactionId: transactionId,
            message: '验证期免费体验24小时！',
            tier: tier,
            validUntil: simulatedOrder.validUntil,
            note: '正式版本将收费，感谢您的测试！'
        };
    }
    
    // 授予临时访问权限
    grantTemporaryAccess(fingerprint, tier, hours) {
        const expiry = Date.now() + (hours * 60 * 60 * 1000);
        
        this.userExperiences.set(fingerprint, {
            tier: tier,
            expiry: expiry,
            originalTier: 'free',
            isSimulated: true
        });
        
        // 更新用户管理器中的等级
        userManager.simulateUpgrade(fingerprint, tier, hours * 60 * 60 * 1000);
    }
    
    // 检查用户是否有临时访问权限
    checkTemporaryAccess(fingerprint) {
        const experience = this.userExperiences.get(fingerprint);
        
        if (!experience) return null;
        
        if (Date.now() > experience.expiry) {
            // 权限已过期，恢复原等级
            this.userExperiences.delete(fingerprint);
            userManager.restoreOriginalTier(fingerprint);
            return null;
        }
        
        return {
            tier: experience.tier,
            timeLeft: Math.max(0, experience.expiry - Date.now()),
            isSimulated: true
        };
    }
}
```

### 5.2 付费意愿数据收集

**核心数据收集策略：**

```javascript
// 付费意愿分析器（简化版）
class PaymentIntentAnalyzer {
    constructor() {
        this.intents = new Map();
        this.conversions = new Map();
    }
    
    // 记录付费意愿
    recordIntent(fingerprint, data) {
        const intent = {
            id: this.generateId(),
            fingerprint: fingerprint,
            tier: data.tier,
            email: data.email,
            amount: data.amount,
            timestamp: new Date(),
            source: data.source || 'upgrade_prompt'
        };
        
        const userIntents = this.intents.get(fingerprint) || [];
        userIntents.push(intent);
        this.intents.set(fingerprint, userIntents);
        
        return intent.id;
    }
    
    // 获取统计数据
    getIntentStatistics() {
        let totalIntents = 0;
        let uniqueUsers = this.intents.size;
        let emailCollected = 0;
        let tierBreakdown = { standard: 0, premium: 0 };
        
        for (let [fingerprint, intents] of this.intents) {
            totalIntents += intents.length;
            const latestIntent = intents[intents.length - 1];
            if (latestIntent.email) emailCollected++;
            tierBreakdown[latestIntent.tier] = (tierBreakdown[latestIntent.tier] || 0) + 1;
        }
        
        return {
            totalIntents,
            uniqueUsers,
            emailCollected,
            emailConversionRate: uniqueUsers > 0 ? (emailCollected / uniqueUsers * 100).toFixed(2) + '%' : '0%',
            tierBreakdown
        };
    }
}
```

### 5.3 A/B测试框架

**简化A/B测试实现：**

```javascript
// A/B测试管理器
class ABTestManager {
    constructor() {
        this.tests = new Map();
        this.assignments = new Map();
        this.results = new Map();
    }
    
    // 获取用户的测试变体
    getVariant(fingerprint, testName) {
        const userAssignments = this.assignments.get(fingerprint) || {};
        
        if (userAssignments[testName]) {
            return userAssignments[testName];
        }
        
        // 基于指纹哈希分配变体
        const hash = this.hashFingerprint(fingerprint + testName);
        const variant = hash % 2 === 0 ? 'A' : 'B';
        
        userAssignments[testName] = variant;
        this.assignments.set(fingerprint, userAssignments);
        
        return variant;
    }
    
    // 记录转化
    recordConversion(fingerprint, testName) {
        const userAssignments = this.assignments.get(fingerprint);
        if (!userAssignments || !userAssignments[testName]) return;
        
        const variant = userAssignments[testName];
        const testResults = this.results.get(testName) || { A: { conversions: 0 }, B: { conversions: 0 } };
        testResults[variant].conversions++;
        this.results.set(testName, testResults);
    }
}
```

### 5.4 用户行为追踪

**行为数据收集：**

```javascript
// 用户行为追踪器（简化版）
class UserBehaviorTracker {
    constructor() {
        this.events = new Map();
        this.sessions = new Map();
    }
    
    // 记录用户事件
    trackEvent(fingerprint, eventType, eventData = {}) {
        const userEvents = this.events.get(fingerprint) || [];
        const event = {
            type: eventType,
            timestamp: Date.now(),
            data: eventData
        };
        
        userEvents.push(event);
        this.events.set(fingerprint, userEvents);
        
        // 处理特殊事件
        if (eventType === 'upgrade_button_click') {
            abTestManager.recordConversion(fingerprint, 'upgrade_prompt_text');
        }
    }
    
    // 计算用户价值评分
    calculateValueScore(fingerprint) {
        const events = this.events.get(fingerprint) || [];
        let score = 0;
        
        events.forEach(event => {
            switch(event.type) {
                case 'page_view': score += 1; break;
                case 'analyze_complete': score += 10; break;
                case 'upgrade_button_click': score += 20; break;
                case 'email_submitted': score += 50; break;
            }
        });
        
        return Math.min(score, 100);
    }
}
```

## 6. 性能优化和安全

### 6.1 系统性能优化方案

**AI调用优化：**

```javascript
// AI性能优化器
class AIPerformanceOptimizer {
    constructor() {
        this.responseCache = new Map();
        this.requestQueue = [];
        this.processing = false;
        this.maxCacheSize = 1000;
        this.cacheTimeout = 3600000; // 1小时
    }
    
    // 智能缓存系统
    getCachedResult(formData) {
        const cacheKey = this.generateCacheKey(formData);
        const cached = this.responseCache.get(cacheKey);
        
        if (!cached) return null;
        
        // 检查缓存是否过期
        if (Date.now() - cached.timestamp > this.cacheTimeout) {
            this.responseCache.delete(cacheKey);
            return null;
        }
        
        return cached.result;
    }
    
    // 缓存分析结果
    cacheResult(formData, result) {
        const cacheKey = this.generateCacheKey(formData);
        
        // 如果缓存已满，删除最旧的项目
        if (this.responseCache.size >= this.maxCacheSize) {
            const oldestKey = this.responseCache.keys().next().value;
            this.responseCache.delete(oldestKey);
        }
        
        this.responseCache.set(cacheKey, {
            result: result,
            timestamp: Date.now()
        });
    }
    
    // 生成缓存键
    generateCacheKey(formData) {
        const keyData = {
            houseType: formData.houseType,
            direction: formData.direction,
            hasPhoto: !!formData.photo,
            // 不包含敏感信息如生辰八字
        };
        
        return crypto.createHash('md5').update(JSON.stringify(keyData)).digest('hex');
    }
    
    // 请求队列管理（防止并发过多）
    async processRequest(analysisFunction, ...args) {
        return new Promise((resolve, reject) => {
            this.requestQueue.push({
                analysisFunction,
                args,
                resolve,
                reject,
                timestamp: Date.now()
            });
            
            this.processQueue();
        });
    }
    
    async processQueue() {
        if (this.processing || this.requestQueue.length === 0) return;
        
        this.processing = true;
        
        while (this.requestQueue.length > 0) {
            const request = this.requestQueue.shift();
            
            try {
                const result = await request.analysisFunction(...request.args);
                request.resolve(result);
            } catch (error) {
                request.reject(error);
            }
            
            // 请求间隔控制
            await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        this.processing = false;
    }
}
```

**内存管理优化：**

```javascript
// 内存管理器
class MemoryManager {
    constructor() {
        this.cleanupInterval = setInterval(() => {
            this.performCleanup();
        }, 30 * 60 * 1000); // 30分钟清理一次
    }
    
    // 定期清理过期数据
    performCleanup() {
        const now = Date.now();
        const maxAge = 24 * 60 * 60 * 1000; // 24小时
        
        // 清理过期的用户会话
        for (let [fingerprint, session] of behaviorTracker.sessions) {
            if (now - session.lastActivity > maxAge) {
                behaviorTracker.sessions.delete(fingerprint);
            }
        }
        
        // 清理过期的模拟升级
        for (let [fingerprint, experience] of validationSimulator.userExperiences) {
            if (now > experience.expiry) {
                validationSimulator.userExperiences.delete(fingerprint);
            }
        }
        
        // 清理过期的缓存
        aiOptimizer.cleanExpiredCache();
        
        console.log('🧹 内存清理完成');
    }
    
    // 获取内存使用情况
    getMemoryUsage() {
        const usage = process.memoryUsage();
        
        return {
            rss: (usage.rss / 1024 / 1024).toFixed(2) + ' MB',
            heapTotal: (usage.heapTotal / 1024 / 1024).toFixed(2) + ' MB',
            heapUsed: (usage.heapUsed / 1024 / 1024).toFixed(2) + ' MB',
            external: (usage.external / 1024 / 1024).toFixed(2) + ' MB'
        };
    }
}
```

### 6.2 数据安全和隐私保护

**数据加密和脱敏：**

```javascript
// 数据安全管理器
class DataSecurityManager {
    constructor() {
        this.encryptionKey = process.env.ENCRYPTION_KEY || 'default-key-change-in-production';
        this.saltRounds = 10;
    }
    
    // 加密敏感数据
    encryptSensitiveData(data) {
        const cipher = crypto.createCipher('aes-256-cbc', this.encryptionKey);
        let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
        encrypted += cipher.final('hex');
        return encrypted;
    }
    
    // 解密敏感数据
    decryptSensitiveData(encryptedData) {
        try {
            const decipher = crypto.createDecipher('aes-256-cbc', this.encryptionKey);
            let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            return JSON.parse(decrypted);
        } catch (error) {
            console.error('解密失败:', error);
            return null;
        }
    }
    
    // 邮箱脱敏显示
    maskEmail(email) {
        if (!email || !email.includes('@')) return email;
        
        const [username, domain] = email.split('@');
        const maskedUsername = username.length > 2 ? 
            username[0] + '*'.repeat(username.length - 2) + username[username.length - 1] :
            '*'.repeat(username.length);
        
        return `${maskedUsername}@${domain}`;
    }
    
    // 数据脱敏用于日志
    sanitizeDataForLogging(data) {
        const sanitized = { ...data };
        
        if (sanitized.email) {
            sanitized.email = this.maskEmail(sanitized.email);
        }
        
        if (sanitized.birthDate) {
            sanitized.birthDate = '[REDACTED]';
        }
        
        if (sanitized.birthTime) {
            sanitized.birthTime = '[REDACTED]';
        }
        
        return sanitized;
    }
    
    // 自动数据清理
    scheduleDataCleanup() {
        // 每日凌晨2点清理过期数据
        setInterval(() => {
            const now = new Date();
            if (now.getHours() === 2 && now.getMinutes() === 0) {
                this.cleanupExpiredData();
            }
        }, 60000); // 每分钟检查一次
    }
    
    cleanupExpiredData() {
        const cutoff = Date.now() - (30 * 24 * 60 * 60 * 1000); // 30天前
        
        // 清理旧的分析记录中的敏感信息
        for (let [id, analysis] of dataManager.analyses) {
            if (analysis.timestamp < cutoff) {
                // 保留统计数据，删除敏感信息
                delete analysis.inputData.birthDate;
                delete analysis.inputData.birthTime;
                delete analysis.inputData.photoName;
            }
        }
        
        console.log('🔒 敏感数据清理完成');
    }
}
```

### 6.3 系统监控和报警

**监控系统：**

```javascript
// 系统监控器
class SystemMonitor {
    constructor() {
        this.metrics = {
            requests: { total: 0, errors: 0, avgTime: 0 },
            memory: { current: 0, peak: 0 },
            ai: { calls: 0, failures: 0, avgTime: 0 },
            users: { active: 0, total: 0 }
        };
        
        this.alerts = [];
        this.thresholds = {
            memoryUsage: 80, // MB
            errorRate: 5,    // %
            responseTime: 5000 // ms
        };
        
        this.startMonitoring();
    }
    
    // 开始监控
    startMonitoring() {
        // 每5分钟收集一次指标
        setInterval(() => {
            this.collectMetrics();
            this.checkThresholds();
        }, 5 * 60 * 1000);
    }
    
    // 收集系统指标
    collectMetrics() {
        const memUsage = process.memoryUsage();
        this.metrics.memory.current = memUsage.heapUsed / 1024 / 1024; // MB
        
        if (this.metrics.memory.current > this.metrics.memory.peak) {
            this.metrics.memory.peak = this.metrics.memory.current;
        }
        
        // 收集AI性能指标
        const aiStats = analyzer.aiManager.getPerformanceStats();
        this.metrics.ai = {
            calls: aiStats.deepseek.calls + aiStats.qwen3.calls,
            failures: aiStats.deepseek.errors + aiStats.qwen3.errors,
            avgTime: (aiStats.deepseek.avgTime + aiStats.qwen3.avgTime) / 2
        };
        
        // 收集用户指标
        this.metrics.users = {
            active: behaviorTracker.sessions.size,
            total: userManager.users.size
        };
    }
    
    // 检查阈值并报警
    checkThresholds() {
        const alerts = [];
        
        // 内存使用率检查
        if (this.metrics.memory.current > this.thresholds.memoryUsage) {
            alerts.push({
                type: 'memory',
                level: 'warning',
                message: `内存使用率过高: ${this.metrics.memory.current.toFixed(2)}MB`,
                timestamp: new Date()
            });
        }
        
        // 错误率检查
        const errorRate = this.metrics.requests.total > 0 ? 
            (this.metrics.requests.errors / this.metrics.requests.total * 100) : 0;
        
        if (errorRate > this.thresholds.errorRate) {
            alerts.push({
                type: 'error_rate',
                level: 'critical',
                message: `错误率过高: ${errorRate.toFixed(2)}%`,
                timestamp: new Date()
            });
        }
        
        // AI响应时间检查
        if (this.metrics.ai.avgTime > this.thresholds.responseTime) {
            alerts.push({
                type: 'ai_performance',
                level: 'warning',
                message: `AI响应时间过长: ${this.metrics.ai.avgTime}ms`,
                timestamp: new Date()
            });
        }
        
        // 存储新警报
        alerts.forEach(alert => {
            this.alerts.push(alert);
            console.warn(`🚨 系统警报 [${alert.level}]: ${alert.message}`);
        });
        
        // 保持警报历史在合理范围内
        if (this.alerts.length > 100) {
            this.alerts = this.alerts.slice(-100);
        }
    }
    
    // 获取系统健康状态
    getHealthStatus() {
        const recentAlerts = this.alerts.filter(alert => 
            Date.now() - alert.timestamp.getTime() < 60 * 60 * 1000 // 1小时内
        );
        
        const criticalAlerts = recentAlerts.filter(alert => alert.level === 'critical');
        
        return {
            status: criticalAlerts.length > 0 ? 'critical' : 
                   recentAlerts.length > 0 ? 'warning' : 'healthy',
            metrics: this.metrics,
            alerts: recentAlerts,
            uptime: process.uptime(),
            timestamp: new Date()
        };
    }
}
```

### 6.4 备份和恢复策略

**数据备份系统：**

```javascript
// 数据备份管理器
class BackupManager {
    constructor() {
        this.backupPath = './backups';
        this.scheduleBackups();
    }
    
    // 创建数据备份
    async createBackup() {
        const timestamp = new Date().toISOString().replace(/:/g, '-');
        const backupData = {
            timestamp: timestamp,
            users: Array.from(userManager.users.entries()),
            analyses: Array.from(dataManager.analyses.entries()),
            upgradeIntents: Array.from(paymentIntentAnalyzer.intents.entries()),
            systemStats: systemMonitor.metrics,
            version: '1.0.0'
        };
        
        const filename = `backup-${timestamp}.json`;
        const filepath = `${this.backupPath}/${filename}`;
        
        try {
            // 确保备份目录存在
            if (!require('fs').existsSync(this.backupPath)) {
                require('fs').mkdirSync(this.backupPath, { recursive: true });
            }
            
            // 写入备份文件
            require('fs').writeFileSync(filepath, JSON.stringify(backupData, null, 2));
            
            console.log(`💾 数据备份成功: ${filename}`);
            
            // 清理旧备份（保留最近7天）
            this.cleanupOldBackups();
            
            return filename;
        } catch (error) {
            console.error('❌ 备份失败:', error);
            throw error;
        }
    }
    
    // 恢复数据
    async restoreBackup(filename) {
        const filepath = `${this.backupPath}/${filename}`;
        
        try {
            const backupData = JSON.parse(require('fs').readFileSync(filepath, 'utf8'));
            
            // 恢复用户数据
            userManager.users = new Map(backupData.users);
            
            // 恢复分析数据
            dataManager.analyses = new Map(backupData.analyses);
            
            // 恢复升级意愿数据
            paymentIntentAnalyzer.intents = new Map(backupData.upgradeIntents);
            
            console.log(`🔄 数据恢复成功: ${filename}`);
            return true;
        } catch (error) {
            console.error('❌ 恢复失败:', error);
            throw error;
        }
    }
    
    // 定期备份
    scheduleBackups() {
        // 每6小时备份一次
        setInterval(() => {
            this.createBackup().catch(error => {
                console.error('定期备份失败:', error);
            });
        }, 6 * 60 * 60 * 1000);
    }
    
    // 清理旧备份
    cleanupOldBackups() {
        try {
            const files = require('fs').readdirSync(this.backupPath);
            const cutoff = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7天前
            
            files.forEach(file => {
                if (file.startsWith('backup-')) {
                    const filepath = `${this.backupPath}/${file}`;
                    const stats = require('fs').statSync(filepath);
                    
                    if (stats.mtime.getTime() < cutoff) {
                        require('fs').unlinkSync(filepath);
                        console.log(`🗑️ 删除旧备份: ${file}`);
                    }
                }
            });
        } catch (error) {
            console.error('清理备份失败:', error);
        }
    }
}
```

## 7. 部署和运维

### 7.1 开发环境配置

**本地开发环境设置：**

```bash
# 1. 克隆项目
git clone <repository-url>
cd fengshui-website

# 2. 安装依赖
npm install

# 3. 配置环境变量
cp example.env .env
# 编辑 .env 文件，添加API密钥

# 4. 验证配置
node -e "require('./config.js').validateConfig()"

# 5. 启动开发服务器
npm run dev
```

**环境变量配置模板：**

```bash
# .env 文件模板
# AI服务配置
DEEPSEEK_API_KEY=your-deepseek-api-key
QWEN3_API_KEY=your-qwen3-api-key

# 服务器配置
PORT=3000
NODE_ENV=development

# 验证期配置
VALIDATION_MODE=true
ENABLE_PAYMENT=false
COLLECT_EMAILS=true

# 安全配置
ENCRYPTION_KEY=your-encryption-key-change-in-production
ADMIN_KEY=your-admin-dashboard-key

# 可选配置
MAX_FREE_USAGE=999999
CONSULTATION_EMAIL=support@yoursite.com
```

### 7.2 生产环境部署

**部署准备清单：**

```javascript
// 生产环境检查清单
const PRODUCTION_CHECKLIST = {
    security: [
        '更新所有默认密码和密钥',
        '启用HTTPS证书',
        '配置防火墙规则',
        '设置访问日志',
        '启用请求限制'
    ],
    performance: [
        '配置CDN加速',
        '启用Gzip压缩',
        '优化图片资源',
        '配置缓存策略',
        '设置负载均衡（如需要）'
    ],
    monitoring: [
        '配置系统监控',
        '设置错误报警',
        '启用日志收集',
        '配置备份策略',
        '测试恢复流程'
    ],
    business: [
        '配置支付系统（商业化时）',
        '设置邮件服务',
        '配置域名和SSL',
        '准备客服联系方式',
        '法律合规文档'
    ]
};
```

**Docker部署方案：**

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# 复制依赖文件
COPY package*.json ./
RUN npm ci --only=production

# 复制源代码
COPY . .

# 创建必要的目录
RUN mkdir -p uploads backups logs

# 设置权限
RUN chown -R node:node /app
USER node

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/api/health || exit 1

# 启动应用
CMD ["npm", "start"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  fengshui-app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
      - QWEN3_API_KEY=${QWEN3_API_KEY}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
    volumes:
      - ./uploads:/app/uploads
      - ./backups:/app/backups
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - fengshui-app
    restart: unless-stopped
```

### 7.3 CI/CD流程设计

**GitHub Actions工作流：**

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run basic tests
      run: |
        node -e "console.log('Basic syntax check passed')"
        node -e "require('./config.js')"
        node -e "require('./server.js')" &
        sleep 5
        curl -f http://localhost:3000/api/health || exit 1

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to server
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          cd /var/www/fengshui-website
          git pull origin main
          npm ci --only=production
          pm2 reload ecosystem.config.js
```

### 7.4 监控和日志管理

**日志管理系统：**

```javascript
// 日志管理器
class LogManager {
    constructor() {
        this.logPath = './logs';
        this.maxLogSize = 10 * 1024 * 1024; // 10MB
        this.maxLogFiles = 5;
        this.setupLogRotation();
    }
    
    // 记录不同级别的日志
    log(level, message, metadata = {}) {
        const timestamp = new Date().toISOString();
        const logEntry = {
            timestamp,
            level,
            message,
            metadata: this.sanitizeMetadata(metadata),
            pid: process.pid
        };
        
        // 写入文件
        this.writeToFile(level, JSON.stringify(logEntry) + '\n');
        
        // 控制台输出（开发模式）
        if (process.env.NODE_ENV !== 'production') {
            console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);
        }
    }
    
    info(message, metadata) { this.log('info', message, metadata); }
    warn(message, metadata) { this.log('warn', message, metadata); }
    error(message, metadata) { this.log('error', message, metadata); }
    
    // 脱敏处理
    sanitizeMetadata(metadata) {
        const sanitized = { ...metadata };
        
        // 移除敏感信息
        const sensitiveKeys = ['password', 'token', 'apiKey', 'birthDate', 'birthTime'];
        sensitiveKeys.forEach(key => {
            if (sanitized[key]) {
                sanitized[key] = '[REDACTED]';
            }
        });
        
        return sanitized;
    }
    
    // 日志轮转
    setupLogRotation() {
        setInterval(() => {
            this.rotateLogsIfNeeded();
        }, 60 * 60 * 1000); // 每小时检查一次
    }
}
```

**性能监控仪表板：**

```javascript
// 监控仪表板数据提供者
class MonitoringDashboard {
    constructor() {
        this.startTime = Date.now();
        this.metrics = {
            requests: new Map(), // endpoint -> count
            errors: new Map(),   // error type -> count
            performance: new Map(), // operation -> avg time
            users: new Map()     // daily active users
        };
    }
    
    // 生成监控报告
    generateReport() {
        const uptime = Date.now() - this.startTime;
        const memUsage = process.memoryUsage();
        
        return {
            system: {
                uptime: this.formatUptime(uptime),
                memory: {
                    used: `${(memUsage.heapUsed / 1024 / 1024).toFixed(2)} MB`,
                    total: `${(memUsage.heapTotal / 1024 / 1024).toFixed(2)} MB`
                },
                cpu: process.cpuUsage(),
                version: process.version
            },
            business: {
                totalUsers: userManager.users.size,
                todayAnalyses: this.getTodayAnalysesCount(),
                upgradeIntents: paymentIntentAnalyzer.getIntentStatistics().totalIntents,
                conversionRate: this.calculateConversionRate()
            },
            technical: {
                aiPerformance: analyzer.aiManager.getPerformanceStats(),
                topErrors: this.getTopErrors(),
                slowestEndpoints: this.getSlowestEndpoints()
            }
        };
    }
    
    // 格式化运行时间
    formatUptime(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        
        return `${days}d ${hours % 24}h ${minutes % 60}m ${seconds % 60}s`;
    }
}
```

---

## 📋 技术实现方案完整摘要

### 🎯 核心架构
- **3档产品体系**：免费版、标准版($19.99)、定制版($49.99)
- **双AI模型**：DeepSeek + Qwen3智能切换
- **无注册系统**：基于用户指纹识别
- **验证期模式**：模拟付费收集真实意愿数据

### 🔧 主要技术组件
1. **产品分级控制**：统一AI分析，输出分级过滤
2. **权限管理系统**：验证期模拟升级，商业化真实权限
3. **数据收集体系**：行为追踪、A/B测试、付费意愿分析
4. **性能优化**：智能缓存、请求队列、内存管理
5. **安全防护**：数据加密、脱敏处理、自动清理
6. **监控告警**：系统监控、性能分析、自动备份

### 💻 关键API接口
- `POST /api/analyze` - 分析接口升级支持分级
- `GET /api/user-status` - 用户状态和等级查询
- `POST /api/upgrade-intent` - 升级意愿收集
- `GET /api/analytics-dashboard` - 数据分析仪表板

### 🚀 部署方案
- **开发环境**：本地配置简化，环境变量模板
- **生产部署**：Docker容器化，nginx反向代理
- **CI/CD流程**：GitHub Actions自动化部署
- **监控运维**：日志管理、性能监控、备份恢复

### ✅ 验证期特色功能
- **伪付费体验**：完整付费流程但不实际收费
- **数据收集**：付费意愿、用户行为、转化分析
- **A/B测试**：升级文案、定价展示优化
- **临时权限**：24小时高级功能体验

**该技术方案为3档产品验证和商业化提供了完整的技术支撑！**

*【技术实现方案文档已完成】*